Практическая работа 12

Добрый день.

В проекте упрощенно имитируется банковская система, есть два вида клиентов, имеющих статус standard или premium. Если статус standard, то ставка 5%, если статус premium, то 7,5%. 

У каждого клиента имеется изначально 2 счета, капитализируемый и некапитализируемый. 

При создании списка клиентов и их счетов на каждый счет автоматически начисляется определенная сумма - Money, также в информации о счете клиента указана величина итоговой суммы по окончании срока действия счета - FinalMoney. Величина FinalMoney рассчитывается в этом проекте следующим образом: Money * ставка (зависит от статуса клиента) * множитель (если капитализируемый то 2, если нет, то 1).    

Задание 1: в файле BankCheck имеется обобщенный класс с параметризованными параметрами public class BankAccount<T, K>, через который реализовано создание счета определенного типа и с определенной ставкой в зависимости от того, какой клиент. 

Закрытие счета реализовано через изменение id добавлением ему пометки _Closed в конце. При наличии данной пометки любые операции с этим счетом не осуществимы, при этом сам счет остается в списке видимым.

Внутренние переводы между счетами одного клиента реализованы в разделе "Внутренние транзакции". 

Счет также является либо депозитным либо недепозитным. В данной системе от этого зависит лишь наличие комиссии по пополнениям и переводам. 

Задание 2: в файле BankCheck имеются классы public class NoDeposit, public class Deposit: NoDeposit, public class AddMoneyDeposit: IAccountAddMoney<Deposit>, public class AddMoneyNoDeposit: IAccountAddMoney<NoDeposit>, через которые реализована ковариатность. IAccountAddMoney - ковариантный интерфейс, который может учитывать классы Deposit и NoDeposit. Если счет депозитный, то с помощью этих сущностей пользователь уведомляется о том, что при пополнении со счета будет взиматься комиссия. Если счет недепозитный, комиссии не будет. В алгоритме пополнения счета это все учтено таким образом, что объявляя объект более универсального типа NoDeposit можно использовать тип более конкретный, тем самым реализуется ковариантность в проекте (см. файл AddMoneyAccount).  

Задание 3: в файле BankCheck имеются класс public class Transaction : ITransaction<NoDeposit>, через который реализована контравариатность. ITransaction - контравариантный интерфейс, который может учитывать классы Deposit и NoDeposit. Если какой-то один из счетов депозитный, то с помощью этих сущностей пользователь уведомляется о том, что при переводе денежных средств со счета-отправителя будет взиматься комиссия. Если счет недепозитный, комиссии не будет. В алгоритме перевода это все учтено таким образом, что объявляя объект более конкретного типа Deposit можно использовать тип более универсальный, тем самым реализуется контравариантность в проекте (см. файл ExternalFinanceTransaction).

///////////////////////////////////////////////////////////////

Практическая работа 13

Добрый день.

Процесс записывания в журнал событий и уведомления об этих событиях посредством всплывающих окон реализовано через событие public static event Action<string> RecordChanged.
 
В каждом методе, результат выполнения которого должен фиксироваться вышеуказанным способом, событие RecordChanged подписывается на метод public void Handler(string s).

В конце выполнения каждого такого метода в случае выполнения события RecordChanged вызываются методы, на которые это событие подписано: RecordChanged?.Invoke (аргумент в виде строки сообщения о событии).

Строка сообщения о событии, которая в качестве аргумента подается в метод Handler(string s) имеет различный вид в зависимости от того, какой метод выполняется (переводы, пополнение, редактирование данных и т.д.).

Классы, в которых присутствует данная реализация: ListClientsManager, ListClientsConsultant, AccountBankManager.

Более детальное описание процесса на примере метода AddMoneyAccount: в классе AccountBankManager есть метод AddMoneyAccount (пополнение счета), который в свою очередь задействует класс AddMoneyAccount,  в котором 

производятся необходимые операции по пополнению выбранного счета клиента в методе public void AddMoney(), в конце этого метода булева переменная public bool IsRecord принимает значение true, и так как модификатор 

доступа у этой переменной public, то изменение значения этой переменной видно в классе AccountBankManager, и при истинности условия if (AddMoneyAccountWindow.IsRecord == true) срабатывает событие RecordChanged и вызывается 

метод Handler: if (AddMoneyAccountWindow.IsRecord == true)
                    {
                        RecordChanged?.Invoke(AddMoneyAccountWindow.Record);
                        RecordChanged -= Handler;
                    }     

В остальных местах программы этот механизм реализован аналогично.    
